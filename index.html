<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minesweeper Auto Solver</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f4f4f4;
      padding: 20px;
    }
    #controls {
      margin-bottom: 15px;
    }
    #timer {
      font-weight: bold;
      margin-left: 20px;
    }
    #mines-counter {
      font-weight: bold;
      margin-left: 20px;
      color: #d32f2f;
    }
    #status {
      margin: 10px 0;
      font-weight: bold;
      font-size: 18px;
    }
    #instructions {
      margin: 10px 0;
      font-size: 14px;
      color: #666;
    }
    #grid {
      display: grid;
      gap: 2px;
      justify-content: center;
      margin: 20px auto;
    }
    .cell {
      width: 30px;
      height: 30px;
      background-color: #ccc;
      border: 2px outset #999;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
    }
    .cell:hover:not(.revealed):not(.flagged) {
      background-color: #ddd;
    }
    .revealed {
      background-color: #e0e0e0;
      border: 1px solid #999;
      cursor: default;
    }
    .mine {
      background-color: red;
      color: white;
    }
    .flagged {
      background-color: #ff9800;
      color: white;
      border-color: #f57c00;
    }
    .flagged:hover {
      background-color: #ffb74d;
    }
    .wrongly-flagged {
      background-color: #ffcdd2;
      color: red;
    }
    .cell-1 { color: blue; }
    .cell-2 { color: green; }
    .cell-3 { color: red; }
    .cell-4 { color: purple; }
    .cell-5 { color: maroon; }
    .cell-6 { color: turquoise; }
    .cell-7 { color: black; }
    .cell-8 { color: gray; }
    
    #flag-mode {
      margin: 10px;
    }
    
    .flag-mode-active {
      background-color: #ff9800 !important;
      color: white !important;
      border: 2px solid #f57c00 !important;
    }
    
    button {
      margin: 0 5px;
      padding: 8px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Minesweeper Auto Solver</h1>
  <div id="controls">
    <label>Difficulty:
      <select id="difficulty" onchange="resetGame()">
        <option value="easy">Easy (9x9, 10 mines)</option>
        <option value="medium">Medium (16x16, 40 mines)</option>
        <option value="hard">Hard (24x24, 99 mines)</option>
      </select>
    </label>
    <button onclick="resetGame()">New Game</button>
    <button onclick="retryGame()" id="retryBtn">Retry Same Puzzle</button>
    <button onclick="toggleAutoSolve()" id="autoSolveBtn">Start Auto-Solve</button>
    <span id="timer">Time: 0s</span>
    <span id="mines-counter">Mines: 0</span>
  </div>
  
  <div id="flag-mode">
    <button id="flagModeBtn" onclick="toggleFlagMode()">Flag Mode: OFF</button>
    <span style="font-size: 12px; color: #666;">
      (Or right-click to flag/unflag individual cells)
    </span>
  </div>
  
  <div id="instructions">
    Left click to reveal â€¢ Right click or Flag Mode to flag/unflag â€¢ Flag all mines to win!
  </div>
  
  <div id="status">Click Reset to start a new game</div>
  <div id="grid"></div>

  <script>
    let gridSize, numMines;
    let board = [], revealed = [], flagged = [];
    let timer = 0, timerInterval;
    let gameStarted = false, gameEnded = false;
    let autoSolving = false;
    let flagMode = false;
    let savedBoard = []; // Store the original board for retry functionality

    function setDifficulty() {
      const level = document.getElementById('difficulty').value;
      if (level === 'easy') {
        gridSize = 9; numMines = 10;
      } else if (level === 'medium') {
        gridSize = 16; numMines = 40;
      } else {
        gridSize = 24; numMines = 99;
      }
      document.getElementById('grid').style.gridTemplateColumns = `repeat(${gridSize}, 32px)`;
    }

    function createBoard() {
      board = Array(gridSize * gridSize).fill(0);
      revealed = Array(gridSize * gridSize).fill(false);
      flagged = Array(gridSize * gridSize).fill(false);
      placeMines();
      calculateNumbers();
      // Save the board for retry functionality
      savedBoard = [...board];
      updateMinesCounter();
    }

    function placeMines() {
      let placed = 0;
      while (placed < numMines) {
        const idx = Math.floor(Math.random() * board.length);
        if (board[idx] !== 'M') {
          board[idx] = 'M';
          placed++;
        }
      }
    }

    function calculateNumbers() {
      for (let i = 0; i < board.length; i++) {
        if (board[i] === 'M') continue;
        let count = 0;
        const neighbors = getNeighbors(i);
        neighbors.forEach(n => {
          if (board[n] === 'M') count++;
        });
        board[i] = count;
      }
    }

    function getNeighbors(index) {
      const x = index % gridSize;
      const y = Math.floor(index / gridSize);
      const neighbors = [];

      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            neighbors.push(ny * gridSize + nx);
          }
        }
      }
      return neighbors;
    }

    function renderBoard() {
      const grid = document.getElementById("grid");
      grid.innerHTML = '';
      for (let i = 0; i < board.length; i++) {
        const cell = document.createElement("div");
        cell.className = 'cell';
        cell.id = `cell-${i}`;
        cell.onclick = () => handleCellClick(i);
        cell.oncontextmenu = (e) => {
          e.preventDefault();
          toggleFlag(i);
        };
        grid.appendChild(cell);
      }
      updateAllCellDisplays();
    }

    function handleCellClick(index) {
      if (flagMode) {
        toggleFlag(index);
      } else {
        manualReveal(index);
      }
    }

    function toggleFlagMode() {
      flagMode = !flagMode;
      const btn = document.getElementById('flagModeBtn');
      btn.textContent = flagMode ? 'Flag Mode: ON' : 'Flag Mode: OFF';
      if (flagMode) {
        btn.classList.add('flag-mode-active');
      } else {
        btn.classList.remove('flag-mode-active');
      }
    }

    function updateCellDisplay(index) {
      const cell = document.getElementById(`cell-${index}`);
      if (!cell) return;
      
      if (flagged[index]) {
        cell.textContent = 'ðŸš©';
        cell.className = 'cell flagged';
      } else if (revealed[index]) {
        cell.classList.add("revealed");
        const value = board[index];
        if (value === 'M') {
          cell.textContent = 'ðŸ’£';
          cell.classList.add("mine");
        } else if (value > 0) {
          cell.textContent = value;
          cell.classList.add(`cell-${value}`);
        } else {
          cell.textContent = '';
        }
      } else {
        cell.textContent = '';
        cell.className = 'cell';
      }
    }

    function updateAllCellDisplays() {
      for (let i = 0; i < board.length; i++) {
        updateCellDisplay(i);
      }
    }

    function updateMinesCounter() {
      const flaggedCount = flagged.filter(f => f).length;
      const remaining = numMines - flaggedCount;
      document.getElementById('mines-counter').textContent = `Mines: ${remaining}`;
      
      const counter = document.getElementById('mines-counter');
      if (remaining < 0) {
        counter.style.color = '#f44336';
      } else if (remaining === 0) {
        counter.style.color = '#4caf50';
      } else {
        counter.style.color = '#d32f2f';
      }
    }

    function manualReveal(index) {
      if (gameEnded || revealed[index] || flagged[index]) return;
      
      if (!gameStarted) {
        startGame();
      }
      
      if (board[index] === 'M') {
        gameOver(false);
        return;
      }
      
      floodFillReveal(index);
      checkWin();
    }

    function toggleFlag(index) {
      if (gameEnded || revealed[index]) return;
      
      if (!gameStarted && !flagged[index]) {
        startGame();
      }
      
      flagged[index] = !flagged[index];
      updateCellDisplay(index);
      updateMinesCounter();
      
      if (gameStarted) {
        checkWin();
      }
    }

    function floodFillReveal(startIndex) {
      const stack = [startIndex];
      const visited = new Set();

      while (stack.length > 0) {
        const index = stack.pop();
        
        if (visited.has(index) || revealed[index] || flagged[index]) continue;
        visited.add(index);
        
        // Check if this cell is a mine before revealing
        if (board[index] === 'M') {
          revealed[index] = true; // Reveal the mine that was hit
          updateCellDisplay(index);
          gameOver(false);
          return;
        }
        
        revealed[index] = true;
        updateCellDisplay(index);
        
        if (board[index] === 0) {
          const neighbors = getNeighbors(index);
          neighbors.forEach(n => {
            if (!visited.has(n) && !revealed[n] && !flagged[n]) {
              stack.push(n);
            }
          });
        }
      }
    }

    function startTimer() {
      clearInterval(timerInterval);
      timer = 0;
      timerInterval = setInterval(() => {
        timer++;
        document.getElementById("timer").textContent = `Time: ${timer}s`;
      }, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
    }

    function startGame() {
      gameStarted = true;
      gameEnded = false;
      startTimer();
      document.getElementById("status").textContent = "Game in progress...";
    }

    function gameOver(won) {
      gameEnded = true;
      stopTimer();
      
      // Check if auto-solver was running before we reset it
      const wasAutoSolving = autoSolving;
      
      // Stop auto-solving immediately when game ends
      autoSolving = false;
      document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
      
      // Reveal all cells at game end
      for (let i = 0; i < board.length; i++) {
        if (board[i] === 'M') {
          // Show mines (unless correctly flagged)
          if (!flagged[i]) {
            revealed[i] = true;
            updateCellDisplay(i);
          }
        } else {
          // Reveal all non-mine cells
          if (!revealed[i]) {
            revealed[i] = true;
            updateCellDisplay(i);
          }
          // Mark incorrectly flagged non-mine cells
          if (flagged[i]) {
            const cell = document.getElementById(`cell-${i}`);
            cell.classList.add('wrongly-flagged');
            cell.textContent = 'âŒ';
          }
        }
      }
      
      if (won) {
        document.getElementById("status").textContent = `ðŸŽ‰ You won! Time: ${timer}s`;
        document.getElementById("status").style.color = "green";
      } else {
        if (wasAutoSolving) {
          document.getElementById("status").textContent = "ðŸ’¥ AI hit a mine! Game Over! (Click 'Retry Same Puzzle' to try again)";
        } else {
          document.getElementById("status").textContent = "ðŸ’¥ Game Over! (Click 'Retry Same Puzzle' to try again)";
        }
        document.getElementById("status").style.color = "red";
      }
    }

    function checkWin() {
      let revealedCount = 0;
      for (let i = 0; i < board.length; i++) {
        if (revealed[i] && board[i] !== 'M') {
          revealedCount++;
        }
      }
      
      const allNonMinesRevealed = (revealedCount === board.length - numMines);
      
      let correctlyFlagged = 0;
      let incorrectlyFlagged = 0;
      for (let i = 0; i < board.length; i++) {
        if (flagged[i]) {
          if (board[i] === 'M') {
            correctlyFlagged++;
          } else {
            incorrectlyFlagged++;
          }
        }
      }
      
      const allMinesFlagged = (correctlyFlagged === numMines && incorrectlyFlagged === 0);
      
      if (allNonMinesRevealed || allMinesFlagged) {
        gameOver(true);
      }
    }

    function resetGame() {
      stopTimer();
      gameStarted = false;
      gameEnded = false;
      autoSolving = false;
      flagMode = false;
      
      document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
      document.getElementById("flagModeBtn").textContent = "Flag Mode: OFF";
      document.getElementById("flagModeBtn").classList.remove('flag-mode-active');
      document.getElementById("status").textContent = "Click any cell to start";
      document.getElementById("status").style.color = "black";
      document.getElementById("timer").textContent = "Time: 0s";
      
      setDifficulty();
      createBoard(); // This will create a new random board
      renderBoard();
    }

    function retryGame() {
      if (savedBoard.length === 0) {
        // No saved board, create new game
        resetGame();
        return;
      }
      
      stopTimer();
      gameStarted = false;
      gameEnded = false;
      autoSolving = false;
      flagMode = false;
      
      // Restore the saved board
      board = [...savedBoard];
      revealed = Array(gridSize * gridSize).fill(false);
      flagged = Array(gridSize * gridSize).fill(false);
      
      document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
      document.getElementById("flagModeBtn").textContent = "Flag Mode: OFF";
      document.getElementById("flagModeBtn").classList.remove('flag-mode-active');
      document.getElementById("status").textContent = "Same puzzle - Click any cell to start";
      document.getElementById("status").style.color = "black";
      document.getElementById("timer").textContent = "Time: 0s";
      
      updateMinesCounter();
      renderBoard();
    }

    function toggleAutoSolve() {
      if (gameEnded) return;
      
      if (!autoSolving) {
        if (!gameStarted) {
          revealInitialSafeCell();
        }
        autoSolving = true;
        document.getElementById("autoSolveBtn").textContent = "Stop Auto-Solve";
        runSolver();
      } else {
        autoSolving = false;
        document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
      }
    }

    function revealInitialSafeCell() {
      let bestCell = -1;
      let minNeighborMines = Infinity;
      
      for (let i = 0; i < board.length; i++) {
        if (board[i] !== 'M') {
          const neighbors = getNeighbors(i);
          let mineCount = neighbors.filter(n => board[n] === 'M').length;
          if (mineCount < minNeighborMines) {
            minNeighborMines = mineCount;
            bestCell = i;
          }
        }
      }
      
      if (bestCell !== -1) {
        startGame();
        floodFillReveal(bestCell);
        checkWin();
      }
    }

    async function runSolver() {
      let iterations = 0;
      const maxIterations = 2000;
      
      while (autoSolving && !gameEnded && iterations < maxIterations) {
        let progress = false;
        
        progress = await basicConstraintSolving() || progress;
        
        // Check if game ended (mine hit) during solving
        if (gameEnded) {
          autoSolving = false;
          document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
          break;
        }
        
        if (!progress) {
          progress = await advancedConstraintSolving() || progress;
        }
        
        if (gameEnded) {
          autoSolving = false;
          document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
          break;
        }
        
        if (!progress) {
          progress = await makeEducatedGuess() || progress;
        }
        
        if (gameEnded) {
          autoSolving = false;
          document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
          break;
        }
        
        if (!progress) {
          progress = await makeRandomFrontierGuess() || progress;
        }
        
        if (gameEnded) {
          autoSolving = false;
          document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
          break;
        }
        
        if (!progress) {
          autoSolving = false;
          document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
          document.getElementById("status").textContent = "AI solver exhausted all strategies - manual play required";
          break;
        }
        
        await sleep(25);
        iterations++;
      }
      
      if (iterations >= maxIterations && autoSolving) {
        autoSolving = false;
        document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
        document.getElementById("status").textContent = "AI solver reached iteration limit";
      }
    }

    async function basicConstraintSolving() {
      let progress = false;
      
      for (let i = 0; i < board.length; i++) {
        if (!revealed[i] || typeof board[i] !== 'number') continue;
        
        const neighbors = getNeighbors(i);
        const unrevealed = neighbors.filter(n => !revealed[n] && !flagged[n]);
        const flaggedCount = neighbors.filter(n => flagged[n]).length;
        const requiredMines = board[i] - flaggedCount;
        
        if (requiredMines === 0 && unrevealed.length > 0) {
          for (const n of unrevealed) {
            floodFillReveal(n);
            if (gameEnded) return progress; // Stop immediately if mine hit
            await sleep(30);
            progress = true;
          }
        }
        else if (requiredMines === unrevealed.length && unrevealed.length > 0) {
          for (const n of unrevealed) {
            flagged[n] = true;
            updateCellDisplay(n);
            updateMinesCounter();
            await sleep(30);
            progress = true;
          }
        }
        
        if (gameEnded) return progress;
      }
      
      if (progress) {
        if (!gameEnded) { // Only check win if game hasn't ended in loss
          checkWin();
        }
      }
      return progress;
    }

    async function advancedConstraintSolving() {
      const constraints = [];
      
      for (let i = 0; i < board.length; i++) {
        if (!revealed[i] || typeof board[i] !== 'number') continue;
        
        const neighbors = getNeighbors(i);
        const unrevealed = neighbors.filter(n => !revealed[n] && !flagged[n]);
        const flaggedCount = neighbors.filter(n => flagged[n]).length;
        const requiredMines = board[i] - flaggedCount;
        
        if (unrevealed.length > 0) {
          constraints.push({ 
            cells: unrevealed, 
            mines: requiredMines
          });
        }
      }
      
      let progress = false;
      
      for (let i = 0; i < constraints.length && !progress; i++) {
        for (let j = i + 1; j < constraints.length && !progress; j++) {
          const c1 = constraints[i];
          const c2 = constraints[j];
          
          if (c1.cells.every(cell => c2.cells.includes(cell))) {
            const remainingCells = c2.cells.filter(cell => !c1.cells.includes(cell));
            const remainingMines = c2.mines - c1.mines;
            
            if (remainingMines === 0) {
              for (const cell of remainingCells) {
                floodFillReveal(cell);
                if (gameEnded) return progress; // Stop if mine hit
                await sleep(30);
                progress = true;
              }
            } else if (remainingMines === remainingCells.length) {
              for (const cell of remainingCells) {
                flagged[cell] = true;
                updateCellDisplay(cell);
                updateMinesCounter();
                await sleep(30);
                progress = true;
              }
            }
          }
        }
      }
      
      if (progress) {
        if (!gameEnded) { // Only check win if game hasn't ended in loss
          checkWin();
        }
      }
      return progress;
    }

    async function makeEducatedGuess() {
      const frontierCells = [];
      
      for (let i = 0; i < board.length; i++) {
        if (revealed[i] || flagged[i]) continue;
        
        const neighbors = getNeighbors(i);
        const hasRevealedNeighbor = neighbors.some(n => revealed[n] && typeof board[n] === 'number');
        
        if (hasRevealedNeighbor) {
          const x = i % gridSize;
          const y = Math.floor(i / gridSize);
          const isCorner = (x === 0 || x === gridSize - 1) && (y === 0 || y === gridSize - 1);
          const isEdge = x === 0 || x === gridSize - 1 || y === 0 || y === gridSize - 1;
          
          frontierCells.push({ 
            index: i, 
            isCorner, 
            isEdge,
            revealedNeighbors: neighbors.filter(n => revealed[n]).length
          });
        }
      }
      
      if (frontierCells.length > 0) {
        frontierCells.sort((a, b) => {
          if (a.isCorner && !b.isCorner) return -1;
          if (!a.isCorner && b.isCorner) return 1;
          if (a.isEdge && !b.isEdge) return -1;
          if (!a.isEdge && b.isEdge) return 1;
          return b.revealedNeighbors - a.revealedNeighbors;
        });
        
        const bestCell = frontierCells[0];
        floodFillReveal(bestCell.index);
        if (!gameEnded) { // Only check win if no mine was hit
          checkWin();
        }
        return true;
      }
      
      return false;
    }

    async function makeRandomFrontierGuess() {
      const frontierCells = [];
      
      for (let i = 0; i < board.length; i++) {
        if (revealed[i] || flagged[i]) continue;
        
        const neighbors = getNeighbors(i);
        const hasRevealedNeighbor = neighbors.some(n => revealed[n] && typeof board[n] === 'number');
        
        if (hasRevealedNeighbor) {
          frontierCells.push(i);
        }
      }
      
      if (frontierCells.length > 0) {
        const randomCell = frontierCells[Math.floor(Math.random() * frontierCells.length)];
        floodFillReveal(randomCell);
        if (!gameEnded) { // Only check win if no mine was hit
          checkWin();
        }
        return true;
      }
      
      return false;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Initialize the game
    resetGame();
  </script>
</body>
</html>
