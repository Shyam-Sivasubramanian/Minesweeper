<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minesweeper Auto Solver</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f4f4f4;
      padding: 20px;
    }
    #controls {
      margin-bottom: 15px;
    }
    #timer {
      font-weight: bold;
      margin-left: 20px;
    }
    #status {
      margin: 10px 0;
      font-weight: bold;
      font-size: 18px;
    }
    #grid {
      display: grid;
      gap: 2px;
      justify-content: center;
      margin: 20px auto;
    }
    .cell {
      width: 30px;
      height: 30px;
      background-color: #ccc;
      border: 2px outset #999;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
    }
    .revealed {
      background-color: #e0e0e0;
      border: 1px solid #999;
    }
    .mine {
      background-color: red;
      color: white;
    }
    .flagged {
      background-color: orange;
      color: white;
    }
    .cell-1 { color: blue; }
    .cell-2 { color: green; }
    .cell-3 { color: red; }
    .cell-4 { color: purple; }
    .cell-5 { color: maroon; }
    .cell-6 { color: turquoise; }
    .cell-7 { color: black; }
    .cell-8 { color: gray; }
  </style>
</head>
<body>
  <h1>Minesweeper Auto Solver</h1>
  <div id="controls">
    <label>Difficulty:
      <select id="difficulty" onchange="resetGame()">
        <option value="easy">Easy (9x9, 10 mines)</option>
        <option value="medium">Medium (16x16, 40 mines)</option>
        <option value="hard">Hard (24x24, 99 mines)</option>
      </select>
    </label>
    <button onclick="resetGame()">Reset Game</button>
    <button onclick="toggleAutoSolve()" id="autoSolveBtn">Start Auto-Solve</button>
    <span id="timer">Time: 0s</span>
  </div>
  <div id="status">Click Reset to start a new game</div>
  <div id="grid"></div>

  <script>
    let gridSize, numMines;
    let board = [], revealed = [], flagged = [];
    let timer = 0, timerInterval;
    let gameStarted = false, gameEnded = false;
    let autoSolving = false;

    function setDifficulty() {
      const level = document.getElementById('difficulty').value;
      if (level === 'easy') {
        gridSize = 9; numMines = 10;
      } else if (level === 'medium') {
        gridSize = 16; numMines = 40;
      } else {
        gridSize = 24; numMines = 99;
      }
      document.getElementById('grid').style.gridTemplateColumns = `repeat(${gridSize}, 32px)`;
    }

    function createBoard() {
      board = Array(gridSize * gridSize).fill(0);
      revealed = Array(gridSize * gridSize).fill(false);
      flagged = Array(gridSize * gridSize).fill(false);
      placeMines();
      calculateNumbers();
    }

    function placeMines() {
      let placed = 0;
      while (placed < numMines) {
        const idx = Math.floor(Math.random() * board.length);
        if (board[idx] !== 'M') {
          board[idx] = 'M';
          placed++;
        }
      }
    }

    function calculateNumbers() {
      for (let i = 0; i < board.length; i++) {
        if (board[i] === 'M') continue;
        let count = 0;
        const neighbors = getNeighbors(i);
        neighbors.forEach(n => {
          if (board[n] === 'M') count++;
        });
        board[i] = count;
      }
    }

    function getNeighbors(index) {
      const x = index % gridSize;
      const y = Math.floor(index / gridSize);
      const neighbors = [];

      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            neighbors.push(ny * gridSize + nx);
          }
        }
      }
      return neighbors;
    }

    function renderBoard() {
      const grid = document.getElementById("grid");
      grid.innerHTML = '';
      for (let i = 0; i < board.length; i++) {
        const cell = document.createElement("div");
        cell.className = 'cell';
        cell.id = `cell-${i}`;
        cell.onclick = () => manualReveal(i);
        cell.oncontextmenu = (e) => {
          e.preventDefault();
          toggleFlag(i);
        };
        grid.appendChild(cell);
      }
    }

    function updateCellDisplay(index) {
      const cell = document.getElementById(`cell-${index}`);
      if (flagged[index]) {
        cell.textContent = 'ðŸš©';
        cell.className = 'cell flagged';
      } else if (revealed[index]) {
        cell.classList.add("revealed");
        const value = board[index];
        if (value === 'M') {
          cell.textContent = 'ðŸ’£';
          cell.classList.add("mine");
        } else if (value > 0) {
          cell.textContent = value;
          cell.classList.add(`cell-${value}`);
        }
      } else {
        cell.textContent = '';
        cell.className = 'cell';
      }
    }

    function manualReveal(index) {
      if (gameEnded || revealed[index] || flagged[index]) return;
      
      if (!gameStarted) {
        startGame();
      }
      
      if (board[index] === 'M') {
        gameOver(false);
        return;
      }
      
      floodFillReveal(index);
      checkWin();
    }

    function toggleFlag(index) {
      if (gameEnded || revealed[index]) return;
      
      flagged[index] = !flagged[index];
      updateCellDisplay(index);
    }

    function floodFillReveal(startIndex) {
      const stack = [startIndex];
      const visited = new Set();

      while (stack.length > 0) {
        const index = stack.pop();
        
        if (visited.has(index) || revealed[index] || flagged[index]) continue;
        visited.add(index);
        
        revealed[index] = true;
        updateCellDisplay(index);
        
        // If this cell is a 0, reveal all neighbors
        if (board[index] === 0) {
          const neighbors = getNeighbors(index);
          neighbors.forEach(n => {
            if (!visited.has(n) && !revealed[n] && !flagged[n]) {
              stack.push(n);
            }
          });
        }
      }
    }

    function startTimer() {
      clearInterval(timerInterval);
      timer = 0;
      timerInterval = setInterval(() => {
        timer++;
        document.getElementById("timer").textContent = `Time: ${timer}s`;
      }, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
    }

    function startGame() {
      gameStarted = true;
      gameEnded = false;
      startTimer();
      document.getElementById("status").textContent = "Game in progress...";
    }

    function gameOver(won) {
      gameEnded = true;
      stopTimer();
      autoSolving = false;
      document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
      
      // Reveal all mines
      for (let i = 0; i < board.length; i++) {
        if (board[i] === 'M') {
          revealed[i] = true;
          updateCellDisplay(i);
        }
      }
      
      if (won) {
        document.getElementById("status").textContent = `ðŸŽ‰ You won! Time: ${timer}s`;
        document.getElementById("status").style.color = "green";
      } else {
        document.getElementById("status").textContent = "ðŸ’¥ Game Over!";
        document.getElementById("status").style.color = "red";
      }
    }

    function checkWin() {
      let revealedCount = 0;
      for (let i = 0; i < board.length; i++) {
        if (revealed[i] && board[i] !== 'M') {
          revealedCount++;
        }
      }
      
      if (revealedCount === board.length - numMines) {
        gameOver(true);
      }
    }

    function resetGame() {
      stopTimer();
      gameStarted = false;
      gameEnded = false;
      autoSolving = false;
      document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
      document.getElementById("status").textContent = "Click any cell to start";
      document.getElementById("status").style.color = "black";
      document.getElementById("timer").textContent = "Time: 0s";
      
      setDifficulty();
      createBoard();
      renderBoard();
    }

    function toggleAutoSolve() {
      if (gameEnded) return;
      
      if (!autoSolving) {
        if (!gameStarted) {
          // Start game by revealing a safe cell
          revealInitialSafeCell();
        }
        autoSolving = true;
        document.getElementById("autoSolveBtn").textContent = "Stop Auto-Solve";
        runSolver();
      } else {
        autoSolving = false;
        document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
      }
    }

    function revealInitialSafeCell() {
      // Find a cell with 0 mines around it for best opening
      let bestCell = -1;
      let minNeighborMines = Infinity;
      
      for (let i = 0; i < board.length; i++) {
        if (board[i] !== 'M') {
          const neighbors = getNeighbors(i);
          let mineCount = neighbors.filter(n => board[n] === 'M').length;
          if (mineCount < minNeighborMines) {
            minNeighborMines = mineCount;
            bestCell = i;
          }
        }
      }
      
      if (bestCell !== -1) {
        startGame();
        floodFillReveal(bestCell);
        checkWin();
      }
    }

    async function runSolver() {
      let iterations = 0;
      const maxIterations = 2000; // Increased iteration limit
      
      while (autoSolving && !gameEnded && iterations < maxIterations) {
        let progress = false;
        
        // 1. Basic constraint solving (fast and reliable)
        progress = await basicConstraintSolving() || progress;
        
        if (gameEnded) break;
        
        // 2. Advanced constraint solving (more complex patterns)
        if (!progress) {
          progress = await advancedConstraintSolving() || progress;
        }
        
        if (gameEnded) break;
        
        // 3. Tank solver approach for complex situations
        if (!progress) {
          progress = await tankSolverApproach() || progress;
        }
        
        if (gameEnded) break;
        
        // 4. Educated guessing (probabilistic)
        if (!progress) {
          progress = await makeEducatedGuess() || progress;
        }
        
        if (gameEnded) break;
        
        // 5. If all else fails, make a random guess on frontier
        if (!progress) {
          progress = await makeRandomFrontierGuess() || progress;
        }
        
        // If still no progress, we're truly stuck
        if (!progress) {
          autoSolving = false;
          document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
          document.getElementById("status").textContent = "AI solver exhausted all strategies - manual play required";
          break;
        }
        
        await sleep(25); // Slightly faster animation
        iterations++;
      }
      
      if (iterations >= maxIterations) {
        autoSolving = false;
        document.getElementById("autoSolveBtn").textContent = "Start Auto-Solve";
        document.getElementById("status").textContent = "AI solver reached iteration limit";
      }
    }

    async function tankSolverApproach() {
      // Implement a simplified version of the "tank" algorithm
      // This tries to enumerate all possible mine configurations
      const constraints = [];
      
      // Build constraints
      for (let i = 0; i < board.length; i++) {
        if (!revealed[i] || typeof board[i] !== 'number') continue;
        
        const neighbors = getNeighbors(i);
        const unrevealed = neighbors.filter(n => !revealed[n] && !flagged[n]);
        const flaggedCount = neighbors.filter(n => flagged[n]).length;
        const requiredMines = board[i] - flaggedCount;
        
        if (unrevealed.length > 0) {
          constraints.push({ cells: unrevealed, mines: requiredMines });
        }
      }
      
      if (constraints.length === 0) return false;
      
      // Get all frontier cells
      const frontierCells = [...new Set(constraints.flatMap(c => c.cells))];
      
      if (frontierCells.length > 15) {
        // Too complex for brute force, fall back to heuristics
        return false;
      }
      
      // Try all possible mine configurations (simplified)
      const validConfigurations = [];
      const totalConfigs = Math.pow(2, frontierCells.length);
      
      // Limit configurations to prevent timeout
      const maxConfigs = Math.min(totalConfigs, 1024);
      
      for (let config = 0; config < maxConfigs; config++) {
        const mineConfig = [];
        
        for (let i = 0; i < frontierCells.length; i++) {
          mineConfig.push((config & (1 << i)) !== 0);
        }
        
        // Check if this configuration satisfies all constraints
        let valid = true;
        for (const constraint of constraints) {
          let mineCount = 0;
          for (const cell of constraint.cells) {
            const cellIndex = frontierCells.indexOf(cell);
            if (cellIndex !== -1 && mineConfig[cellIndex]) {
              mineCount++;
            }
          }
          
          if (mineCount !== constraint.mines) {
            valid = false;
            break;
          }
        }
        
        if (valid) {
          validConfigurations.push(mineConfig);
        }
      }
      
      if (validConfigurations.length === 0) return false;
      
      // Find cells that are always safe or always mines
      let progress = false;
      
      for (let i = 0; i < frontierCells.length; i++) {
        const cell = frontierCells[i];
        const alwaysMine = validConfigurations.every(config => config[i]);
        const alwaysSafe = validConfigurations.every(config => !config[i]);
        
        if (alwaysSafe) {
          floodFillReveal(cell);
          await sleep(30);
          progress = true;
        } else if (alwaysMine) {
          flagged[cell] = true;
          updateCellDisplay(cell);
          await sleep(30);
          progress = true;
        }
      }
      
      if (progress) {
        checkWin();
      }
      
      return progress;
    }

    async function makeRandomFrontierGuess() {
      // Last resort: make a random guess on a frontier cell
      const frontierCells = [];
      
      for (let i = 0; i < board.length; i++) {
        if (revealed[i] || flagged[i]) continue;
        
        const neighbors = getNeighbors(i);
        const hasRevealedNeighbor = neighbors.some(n => revealed[n] && typeof board[n] === 'number');
        
        if (hasRevealedNeighbor) {
          frontierCells.push(i);
        }
      }
      
      if (frontierCells.length > 0) {
        const randomCell = frontierCells[Math.floor(Math.random() * frontierCells.length)];
        floodFillReveal(randomCell);
        checkWin();
        return true;
      }
      
      return false;
    }

    async function basicConstraintSolving() {
      let progress = false;
      
      for (let i = 0; i < board.length; i++) {
        if (!revealed[i] || typeof board[i] !== 'number') continue;
        
        const neighbors = getNeighbors(i);
        const unrevealed = neighbors.filter(n => !revealed[n] && !flagged[n]);
        const flaggedCount = neighbors.filter(n => flagged[n]).length;
        const requiredMines = board[i] - flaggedCount;
        
        // If we've found all mines around this cell, reveal the rest
        if (requiredMines === 0 && unrevealed.length > 0) {
          for (const n of unrevealed) {
            floodFillReveal(n);
            await sleep(30);
            progress = true;
          }
        }
        // If remaining unrevealed cells must all be mines, flag them
        else if (requiredMines === unrevealed.length && unrevealed.length > 0) {
          for (const n of unrevealed) {
            flagged[n] = true;
            updateCellDisplay(n);
            await sleep(30);
            progress = true;
          }
        }
        
        if (gameEnded) return progress;
      }
      
      if (progress) {
        checkWin();
      }
      return progress;
    }

    async function advancedConstraintSolving() {
      const constraints = [];
      
      // Build constraints from revealed numbered cells
      for (let i = 0; i < board.length; i++) {
        if (!revealed[i] || typeof board[i] !== 'number') continue;
        
        const neighbors = getNeighbors(i);
        const unrevealed = neighbors.filter(n => !revealed[n] && !flagged[n]);
        const flaggedCount = neighbors.filter(n => flagged[n]).length;
        const requiredMines = board[i] - flaggedCount;
        
        if (unrevealed.length > 0) {
          constraints.push({ 
            cells: unrevealed, 
            mines: requiredMines,
            center: i 
          });
        }
      }
      
      // Advanced constraint solving with multiple techniques
      let progress = false;
      
      // 1. Subset/superset analysis
      for (let i = 0; i < constraints.length && !progress; i++) {
        for (let j = i + 1; j < constraints.length && !progress; j++) {
          const c1 = constraints[i];
          const c2 = constraints[j];
          
          // Check if c1 is subset of c2
          if (c1.cells.every(cell => c2.cells.includes(cell))) {
            const remainingCells = c2.cells.filter(cell => !c1.cells.includes(cell));
            const remainingMines = c2.mines - c1.mines;
            
            if (remainingMines === 0) {
              // All remaining cells are safe
              for (const cell of remainingCells) {
                floodFillReveal(cell);
                await sleep(30);
                progress = true;
              }
            } else if (remainingMines === remainingCells.length) {
              // All remaining cells are mines
              for (const cell of remainingCells) {
                flagged[cell] = true;
                updateCellDisplay(cell);
                await sleep(30);
                progress = true;
              }
            }
          }
          
          // Check if c2 is subset of c1
          if (c2.cells.every(cell => c1.cells.includes(cell))) {
            const remainingCells = c1.cells.filter(cell => !c2.cells.includes(cell));
            const remainingMines = c1.mines - c2.mines;
            
            if (remainingMines === 0) {
              for (const cell of remainingCells) {
                floodFillReveal(cell);
                await sleep(30);
                progress = true;
              }
            } else if (remainingMines === remainingCells.length) {
              for (const cell of remainingCells) {
                flagged[cell] = true;
                updateCellDisplay(cell);
                await sleep(30);
                progress = true;
              }
            }
          }
        }
      }
      
      // 2. Intersection analysis
      if (!progress) {
        for (let i = 0; i < constraints.length && !progress; i++) {
          for (let j = i + 1; j < constraints.length && !progress; j++) {
            const c1 = constraints[i];
            const c2 = constraints[j];
            const intersection = c1.cells.filter(cell => c2.cells.includes(cell));
            
            if (intersection.length > 0 && intersection.length < c1.cells.length && intersection.length < c2.cells.length) {
              const c1Only = c1.cells.filter(cell => !c2.cells.includes(cell));
              const c2Only = c2.cells.filter(cell => !c1.cells.includes(cell));
              
              // Try different mine distributions in intersection
              for (let minesInIntersection = Math.max(0, c1.mines - c1Only.length); 
                   minesInIntersection <= Math.min(intersection.length, c1.mines, c2.mines); 
                   minesInIntersection++) {
                
                const c1OnlyMines = c1.mines - minesInIntersection;
                const c2OnlyMines = c2.mines - minesInIntersection;
                
                if (c1OnlyMines >= 0 && c1OnlyMines <= c1Only.length && 
                    c2OnlyMines >= 0 && c2OnlyMines <= c2Only.length) {
                  
                  if (c1OnlyMines === 0) {
                    // All c1Only cells are safe
                    for (const cell of c1Only) {
                      floodFillReveal(cell);
                      await sleep(30);
                      progress = true;
                    }
                  } else if (c1OnlyMines === c1Only.length) {
                    // All c1Only cells are mines
                    for (const cell of c1Only) {
                      flagged[cell] = true;
                      updateCellDisplay(cell);
                      await sleep(30);
                      progress = true;
                    }
                  }
                  
                  if (c2OnlyMines === 0) {
                    // All c2Only cells are safe
                    for (const cell of c2Only) {
                      floodFillReveal(cell);
                      await sleep(30);
                      progress = true;
                    }
                  } else if (c2OnlyMines === c2Only.length) {
                    // All c2Only cells are mines
                    for (const cell of c2Only) {
                      flagged[cell] = true;
                      updateCellDisplay(cell);
                      await sleep(30);
                      progress = true;
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      if (progress) {
        checkWin();
      }
      return progress;
    }

    async function makeEducatedGuess() {
      // Advanced probabilistic analysis
      const cellProbabilities = calculateCellProbabilities();
      
      // Find cells with probability 0 (definitely safe)
      for (const [cell, prob] of cellProbabilities) {
        if (prob === 0) {
          floodFillReveal(cell);
          checkWin();
          return true;
        }
      }
      
      // Find cells with probability 1 (definitely mines)
      for (const [cell, prob] of cellProbabilities) {
        if (prob === 1) {
          flagged[cell] = true;
          updateCellDisplay(cell);
          await sleep(30);
          return true;
        }
      }
      
      // If no definite moves, make educated guess on lowest probability cell
      if (cellProbabilities.length > 0) {
        const sortedCells = cellProbabilities.sort((a, b) => a[1] - b[1]);
        const bestCell = sortedCells[0][0];
        const bestProbability = sortedCells[0][1];
        
        // Only guess if probability is reasonable
        if (bestProbability <= 0.4) {
          floodFillReveal(bestCell);
          checkWin();
          return true;
        }
      }
      
      // Last resort: try corner/edge strategy
      return tryCornerEdgeStrategy();
    }

    function calculateCellProbabilities() {
      const probabilities = [];
      const constraints = [];
      
      // Build constraint system
      for (let i = 0; i < board.length; i++) {
        if (!revealed[i] || typeof board[i] !== 'number') continue;
        
        const neighbors = getNeighbors(i);
        const unrevealed = neighbors.filter(n => !revealed[n] && !flagged[n]);
        const flaggedCount = neighbors.filter(n => flagged[n]).length;
        const requiredMines = board[i] - flaggedCount;
        
        if (unrevealed.length > 0) {
          constraints.push({ 
            cells: unrevealed, 
            mines: requiredMines 
          });
        }
      }
      
      // Get all frontier cells (unrevealed cells adjacent to revealed numbers)
      const frontierCells = new Set();
      constraints.forEach(c => c.cells.forEach(cell => frontierCells.add(cell)));
      
      // Calculate probability for each frontier cell
      for (const cell of frontierCells) {
        if (revealed[cell] || flagged[cell]) continue;
        
        const relevantConstraints = constraints.filter(c => c.cells.includes(cell));
        
        if (relevantConstraints.length === 0) continue;
        
        // Simple probability calculation based on local constraints
        let totalProb = 0;
        let count = 0;
        
        for (const constraint of relevantConstraints) {
          if (constraint.cells.length > 0) {
            const prob = constraint.mines / constraint.cells.length;
            totalProb += prob;
            count++;
          }
        }
        
        if (count > 0) {
          probabilities.push([cell, totalProb / count]);
        }
      }
      
      return probabilities;
    }

    async function tryCornerEdgeStrategy() {
      // Try corners first, then edges, as they statistically have fewer mines
      const unrevealedCells = [];
      
      for (let i = 0; i < board.length; i++) {
        if (!revealed[i] && !flagged[i]) {
          const x = i % gridSize;
          const y = Math.floor(i / gridSize);
          const neighbors = getNeighbors(i);
          const revealedNeighbors = neighbors.filter(n => revealed[n]).length;
          
          // Prioritize cells with more revealed neighbors (more information)
          unrevealedCells.push({ 
            index: i, 
            x, 
            y, 
            revealedNeighbors,
            isCorner: (x === 0 || x === gridSize - 1) && (y === 0 || y === gridSize - 1),
            isEdge: x === 0 || x === gridSize - 1 || y === 0 || y === gridSize - 1
          });
        }
      }
      
      // Sort by preference: corners first, then edges, then by revealed neighbors
      unrevealedCells.sort((a, b) => {
        if (a.isCorner && !b.isCorner) return -1;
        if (!a.isCorner && b.isCorner) return 1;
        if (a.isEdge && !b.isEdge) return -1;
        if (!a.isEdge && b.isEdge) return 1;
        return b.revealedNeighbors - a.revealedNeighbors;
      });
      
      // Try the best candidate
      if (unrevealedCells.length > 0) {
        const bestCell = unrevealedCells[0];
        floodFillReveal(bestCell.index);
        checkWin();
        return true;
      }
      
      return false;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Initialize the game
    resetGame();
  </script>
</body>
</html>
